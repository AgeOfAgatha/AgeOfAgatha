//[GEOMETRY SHADER]
#version 330 core
layout (triangles) in;// 3 vertices in
layout (triangle_strip) out;
layout (max_vertices = 21) out;// 4 per quad * 3 triangle vertices + 6 for near/far caps

uniform vec3 LightPos;
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;

float EPSILON = 0.01;

// Emit a quad using a triangle strip
void EmitQuad(vec3 StartVertex, vec3 EndVertex){
    // Vertex #1: the starting vertex (just a tiny bit below the original edge)
    vec3 LightDir = normalize(StartVertex - LightPos);
    gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4((StartVertex + LightDir * EPSILON), 1.0);
    EmitVertex();
 
    // Vertex #2: the starting vertex projected to infinity
    gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4(LightDir, 0.0);
    EmitVertex();
    
    // Vertex #3: the ending vertex (just a tiny bit below the original edge)
    LightDir = normalize(EndVertex - LightPos);
    gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4((EndVertex + LightDir * EPSILON), 1.0);
    EmitVertex();
    
    // Vertex #4: the ending vertex projected to infinity
    gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4(LightDir , 0.0);
    EmitVertex();

    EndPrimitive();
}


void main(){
    int i;

    // for (i = 0; i < gl_in.length(); i++)
    // {
    //     gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * gl_in[i].gl_Position;
    //     EmitVertex();
    // }
    // EndPrimitive();

    vec3 a = gl_in[0].gl_Position.xyz;
    vec3 b = gl_in[1].gl_Position.xyz;
    vec3 c = gl_in[2].gl_Position.xyz;

    vec3 norm = cross((b-a),(c-a));
    vec3 Normal = norm/length(norm);
    vec3 LightDir = normalize(LightPos - a);

    //Handle only light facing triangles
    if (dot(Normal, LightDir) > 0){
        EmitQuad(a, b);
        EmitQuad(b, c);
        EmitQuad(c, a);

        // render the front cap
        LightDir = (normalize(a - LightPos));
        gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4((a + LightDir * EPSILON), 1.0);
        EmitVertex();

        LightDir = (normalize(b - LightPos));
        gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4((b + LightDir * EPSILON), 1.0);
        EmitVertex();

        LightDir = (normalize(c - LightPos));
        gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4((c + LightDir * EPSILON), 1.0);
        EmitVertex();
        EndPrimitive();
 
        // render the back cap
        LightDir = a - LightPos;
        gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4(LightDir, 0.0);
        EmitVertex();

        LightDir = c - LightPos;
        gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4(LightDir, 0.0);
        EmitVertex();

        LightDir = b - LightPos;
        gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * vec4(LightDir, 0.0);
        EmitVertex();
        EndPrimitive();
    }
}
