//[FRAGMENT SHADER]
#version 330

in VERTEXOUT{
    vec4 color;
    vec3 FragPos;
    vec3 Normal;
    vec2 texcoord;
    float blend;
}fragmentin;

layout (location = 0) out vec4 FragColor;

struct light{
    vec3 color;
};

struct direclight{
    light base;
    vec3 direction;
};

struct spotlight{
    direclight direc;
    vec3 position;
    float fov;
    float constant;
    float linear;
    float exponential;
};
uniform sampler2D PositionMap;
uniform sampler2D ColorMap;
uniform sampler2D NormalMap;

uniform vec4 ViewPos;
uniform vec2 ScreenSize;

uniform direclight DirecLight;
uniform spotlight SpotLight;

uniform int LightType;

vec3 CalcLightInternal(vec3 FragPos, vec3 Normal, vec3 FragDiff, float FragSpec, vec3 LightDirection, float Attenuation, vec3 Color){
    //Ambient
    vec3 Lighting = vec3(0.0,0.0,0.0);
    //Diffuse
    vec3 Diffuse = max(dot(Normal, LightDirection), 0.0) * FragDiff * Color;
    //Specular
    vec3 ViewDir  = normalize(ViewPos.xyz - FragPos);
    vec3 HalfwayDir = normalize(LightDirection + ViewDir);  
    vec3 LightReflect = normalize(reflect(-LightDirection, Normal));
    float SpecularFactor = dot(ViewDir, LightReflect) * dot(Normal, HalfwayDir);
    float Specular = pow(max(SpecularFactor, 0.0), 32) * FragSpec;
    //Attenuation
    Diffuse *= Attenuation;
    Specular *= Attenuation;
    Lighting += Diffuse + Diffuse*Specular;

    return Lighting;
}

vec3 CalcDirectionalLight(vec3 FragPos, vec3 Normal, vec3 FragDiff, float FragSpec){
    vec3 LightDirection = DirecLight.direction;
    float Attenuation = 1.0;
    vec3 Color = DirecLight.base.color;

    return CalcLightInternal(FragPos, Normal, FragDiff, FragSpec, LightDirection, Attenuation, Color);
}

vec3 CalcSpotLight(vec3 FragPos, vec3 Normal, vec3 FragDiff, float FragSpec){
    vec3 LightDirection = SpotLight.position - FragPos;
    float Distance = length(LightDirection);
    LightDirection = normalize(LightDirection);
    float Attenuation = 1.0 / (SpotLight.constant + SpotLight.linear * Distance + SpotLight.exponential * Distance * Distance);
    vec3 Color = SpotLight.direc.base.color;

    return CalcLightInternal(FragPos, Normal, FragDiff, FragSpec, LightDirection, Attenuation, Color);
}

void main(){             
    //Get lighting data from GBuffer
    vec2 TexCoords = gl_FragCoord.xy / ScreenSize;
    vec3 FragPos = texture(PositionMap, TexCoords).rgb;
    vec3 Normal = texture(NormalMap, TexCoords).rgb;
    vec3 Diffuse = texture(ColorMap, TexCoords).rgb;
    float Specular = texture(ColorMap, TexCoords).a;

    if (LightType == 1){
        FragColor = vec4(CalcSpotLight(FragPos, Normal, Diffuse, Specular), 1.0);
    }
    if (LightType == 0){
        FragColor = vec4(CalcDirectionalLight(FragPos, Normal, Diffuse, Specular), 1.0);
    }
}