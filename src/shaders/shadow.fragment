//[FRAGMENT SHADER]
#version 330 core
layout (location = 0) out vec4 FragColor;

in VERTEXOUT{
    vec4 Color;
    vec3 FragPos;
    vec3 Normal;
    vec2 TexCoord;
    float Blend;
    vec4 LightFragPos;
}fragmentin;

struct light{
    vec3 color;
};

struct direclight{
    light base;
    vec3 direction;
};

struct spotlight{
    direclight direc;
    vec3 position;
    float fov;
    float constant;
    float linear;
    float exponential;
};
uniform int texture1set;
uniform sampler2D texture1;
uniform int texture2set;
uniform sampler2D texture2;

uniform direclight DirecLight;
uniform spotlight SpotLight;

uniform int LightType;
uniform sampler2D DepthMap;

uniform vec4 ViewPos;

uniform float Far_Plane;
uniform bool Shadows;


// array of offset direction for sampling
vec3 gridSamplingDisk[20] = vec3[](
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1), 
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

float ShadowCalculation(vec3 lightDir)
{
    vec3 projCoords = fragmentin.LightFragPos.xyz / fragmentin.LightFragPos.w;
    projCoords = projCoords * 0.5 + 0.5;
    float closestDepth = texture(DepthMap, projCoords.xy).r; 
    float currentDepth = projCoords.z;
    vec3 normal = normalize(fragmentin.Normal);
    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(DepthMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(DepthMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;        
        }    
    }
    shadow /= 9.0;
    
    if(projCoords.z > 1.0)
        shadow = 0.0;
        
    return shadow;
}

vec3 CalcLightInternal(vec3 LightDirection, float Attenuation, vec3 Color, vec3 FragToLight, float DiskRadius){
	vec3 FragDiff = fragmentin.Color.xyz;

	if (texture1set == 1 || texture2set == 1){
		if (texture1set == 1 && texture2set != 1){
			FragDiff = FragDiff * texture(texture1, fragmentin.TexCoord).xyz;
		}
		if (texture1set != 1 && texture2set == 1){
			FragDiff = FragDiff * texture(texture1, fragmentin.TexCoord).xyz;
		}
		if (texture1set == 1 && texture2set == 1){
			FragDiff = FragDiff * mix(texture(texture1, fragmentin.TexCoord), texture(texture2, fragmentin.TexCoord), fragmentin.Blend).xyz;
		}
	}
	float Shadow = Shadows ? ShadowCalculation(normalize(LightDirection)) : 0.0;   

    //Diffuse
	vec3 Diffuse = max(dot(fragmentin.Normal, LightDirection), 0.0) * Color;
    //Specular
    vec3 ViewDir  = normalize(ViewPos.xyz - fragmentin.FragPos);
    vec3 HalfwayDir = normalize(LightDirection + ViewDir);  
    vec3 LightReflect = normalize(reflect(-LightDirection, fragmentin.Normal));
    float SpecularFactor = dot(ViewDir, LightReflect) * dot(fragmentin.Normal, HalfwayDir);
    float Specular = pow(max(SpecularFactor, 0.0), 32) * fragmentin.Color.w;
    //Attenuation
    Diffuse *= Attenuation;
    Specular *= Attenuation;
	vec3 Lighting = ((1.0 - Shadow) * (Diffuse + Specular)) * FragDiff; 
	
    return Lighting;
}

vec3 CalcDirectionalLight(){
    vec3 LightDirection = DirecLight.direction;
    float Attenuation = 1.0;
    vec3 Color = DirecLight.base.color;
    vec3 FragToLight = vec3(0) - LightDirection;
    
    return CalcLightInternal(LightDirection, Attenuation, Color, FragToLight, 25);
}

vec3 CalcSpotLight(){
    vec3 LightDirection = SpotLight.position - fragmentin.FragPos;
    float Distance = length(LightDirection);
    LightDirection = normalize(LightDirection);
    float Attenuation = 1.0 / (SpotLight.constant + SpotLight.linear * Distance + SpotLight.exponential * Distance * Distance);
    vec3 Color = SpotLight.direc.base.color;
    float DiskRadius = (1.0 - Attenuation) / 25.0;
    vec3 FragToLight = SpotLight.position - fragmentin.FragPos;

    return CalcLightInternal(LightDirection, Attenuation, Color, FragToLight, DiskRadius);
}

void main(){          
    if (LightType == 0){
        FragColor = vec4(CalcSpotLight(), 1.0);
    }
    if (LightType == 1){
        FragColor = vec4(CalcDirectionalLight(), 1.0);
    }
}